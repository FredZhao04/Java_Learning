###冒泡算法 Bubble Sort -- O(N^2)
冒泡排序的基本思想：每次比较两个相邻的元素，如果它们的顺序错误就把它们叫缓过来。

冒泡排序的核心部分是双重嵌套循环，不难看出冒泡排序的时间复杂度是O(N^2)，这是一个非常高的时间复杂度。

```
public class BubbleSort {

	public static void main(String[] args) {
		int[] arr = {8, 23, 89, 12, 45, 32, 11};
		int len = arr.length;
		for(int i = 0; i < len - 1; i++) {
			for(int j = 0; j < len - i - 1; j ++) {
				if(arr[j] > arr[j + 1]) {
					int temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
		//排序后输出
		for(int a : arr) {
			System.out.println(a);
		}
	}
}
```
###快速排序 QuickSort 
每次排序的时候设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。这样在每次交换的时候就不会像冒泡排序一样只能在相邻的数之间进行交换，交换的距离就大得多了。因此总的比较和交换的次数就少了，速度自然就提高了，当然在最坏的情况下，仍可能是相邻的两个数进行了交换。因此快速排序的最差时间复杂度和冒泡排序一样，都是O(N^2)，它的平均时间复杂度为O(NlogN)。

```
public class QuickSort {

	public static void main(String[] args) {
		int[] arr = {8, 23, 89, 12, 45, 32, 11};
		int len = arr.length;
		quickSort(arr, 0, len - 1);
		for(int a : arr) {
			System.out.print(a + "\t");
		}
	}
	
	public static void quickSort(int[] list, int left, int right) {
		int i = left;
		int j = right;
		if(left > right) {
			return;
		}
		int base = list[left];
		while(i != j) {
			//先从右往左找
			while(list[j] >= base && i < j) {
				j--;
			}
			//再从左往右找
			while(list[i] <= base && i < j) {
				i++;
			}
			if(i < j) {
				int temp = list[i];
				list[i] = list[j];
				list[j] = temp;
			}
		}
		
		list[left] = list[i];
		list[i] = base;
		
		quickSort(list, left, i - 1);
		quickSort(list, i + 1, right);
	}
}
```
###队列 Queue
先进先出
```
public class MyQueue {
	private int[] elements;
	private int size;
	private static final int DEFAULT_CAPACITY = 2;
	
	public MyQueue() {
		this(DEFAULT_CAPACITY);
	}
	
	public MyQueue(int capacity) {
		elements = new int[capacity];
	}
	
	public void enqueue(int value) {
		if(size >= elements.length) {
			int[] temp = new int[elements.length * 2];
			System.arraycopy(elements, 0, temp, 0, elements.length);
			elements = temp;
		}
		elements[size++] = value;
	}
	
	public void dequeue() {
		int[] temp = new int[elements.length - 1];
		System.arraycopy(elements, 0, temp, 0, elements.length - 1);
		elements = temp;
		size--;
	}
	
	public boolean empty() {
		return size == 0;
	}
	
	public int getSize() {
		return size;
	}
}
```
###栈 Stack
后进先出
```
public class MyStack {
	private int[] elements;
	private int size;
	private static final int DEFAULT_CAPACITY = 2;
	
	public MyStack() {
		this(DEFAULT_CAPACITY);
	}
	
	public MyStack(int capacity) {
		elements = new int[capacity];
	}
	
	public void push(int value) {
		if(size >= elements.length) {
			int[] temp = new int[elements.length * 2];
			System.arraycopy(elements, 0, temp, 0, elements.length);
			elements = temp;
		}
		elements[size++] = value;
	}
	
	public int pop() {
		return elements[size--];
	}
	
	public int peek() {
		return elements[size - 1];
	}
	
	public boolean empty() {
		return size == 0;
	}
	
	public int getSize() {
		return size;
	}

}
```
###链表 LinkedList
查询慢，增删块

###插入排序 insertion sort
从数组的第二个元素开始,将数组中的每一个元素按照（升序或者降序）规则插入到已排好序的数组中以达到排序的目的.
一般情况下将数组的第一个元素作为起始元素,从第二个元素开始依次插入。由于要插入到的数组是已经排好序的,所以只要从右向左（或者从后向前）找到排序插入点插入元素，以此类推，直到将最后一个数组元素插入到数组中,整个排序过程完成。

时间复杂度：

将有n个元素的数组排序。
最佳情况就是，数组已经是正序排列了，在这种情况下，需要进行的比较操作是 （n-1）次即可。
最坏情况就是，数组是反序排列，那么此时需要进行的比较共有n(n-1)/2次。

插入排序的赋值操作是比较操作的次数加上 (n-1）次。

平均插入排序算法的时间复杂度为 O(n²)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小（eg：量级小于千），那么插入排序是一个不错的选择

###希尔排序 shell sort
插入排序在本身数量较少的时候效率很高，但是如果待排序的数量很大时，效率不理想。

插入排序每次都将右边的数从后往前依次比较，找到位置时，其后的数向右移动一位。我们不希望它一步一步的移动，而是大步移动，这就是希尔排序。

```
public static void sort(Comparable[] a){
        int N = a.length;
        int h = 1;
        while(h < N/3){
            h = 3 * h + 1;
        }
        while(h >= 1){
            for(int i = h; i < N; i++){
                for(int j = i; j >= h; j -= h){
                    if(a[j].compareTo(a[j - h]) < 0){
                        Comparable temp = a[j];
                        a[j] = a[j - h];
                        a[j - h] = temp;
                    }
                }
            }
            h = h / 3;
        }
    }
```

